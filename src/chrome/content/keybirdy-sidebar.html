<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
	<title>KeyBirdy</title>

	<!-- Bootstrap -->
	<link href="css/bootstrap.min.css" rel="stylesheet">
	<script src="js/jquery.min.js"></script>
	<script src="js/logger.js"></script>
	<script src="js/bootstrap.min.js"></script>
	<script src="js/handlebars.min.js"></script>
	<script src="js/fakeLocalStorage.js"></script>
	<script src="js/hkp-client.js"></script>
	<link href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" rel="stylesheet">
	<script src="js/openpgp.js"></script>
	<!--script src="js/fakeLocalStorageHandler.js"></script-->
	<!--script src="js/sha256.min.js"></script>
	<script src="js/vvv-key-cache.js"></script-->
	<script src="js/modules.js"></script>
	<script src="js/key-lookup.js"></script>
</head>
<body>
<style>
      body {
        font-family: 'Fira Mono', monospace;
      }
</style>

<br/><br/>
<div id="keybirdy-content">
asdfhewohhnfopawxmofmwhapocfpowaxmfwxpo
</div>


<!-- handlebars templates -->
<script id="iframe-key-table" type="text/x-handlebars-template">
  <div class="container col-md-3 justify-content-center">
    <div class="row">
      <div class="col-md-12">
        <h4 class="text-primary text-center">KeyBirdy</h4>
        {{#if sender.pgp }}
				<div id="kb-sidebar-status">
					<div class="alert alert-success" role="alert">
						<i class="fa fa-lock fa-lg"></i> Email can be sent encrypted.
					</div>
				</div>
				{{else}}
				<div id="kb-sidebar-status">
          <div class="alert alert-warning" role="alert">
            <i class="fa fa-lock-open fa-lg"></i> You don't have an OpenPGP-Key. Please generate it with Enigmail!
          </div>
        </div>
        {{/if}}

      </div>
      <br/><br/>
      <div class="col-md-12">
					<button type="button" class="btn btn-primary">import</button>
          <table class="table table-sm ">
						<thead>
		        <tr>
		          <th>email</th>
		          <!--th>source</th-->
		          <th>status</th>
		        </tr>
            <tbody>
              {{#each processedRecipients}}
              <tr>
                {{#if this.isInKeyring }}
                  <td class="text-success">{{ this.address }}</td>
									<td class="text-success">{{ this.source }}</td>
                {{else if this.isImportable}}
                  <td class="text-primary">{{ this.address }}</td>
									<td class="text-success">{{ this.source }}</td>
                {{else}}
                  <td class="text-danger">{{ this.address }}</td>
									<td>unavailable</td>
                {{/if}}

              </tr>
              {{/each}}
            </tbody>
        </table>
      </div>
    </div>
  </div>
</script>

<script>
/*
function sendToIframe(data) {
	var iframeEvent = new CustomEvent('keybirdy', {detail: data});
	document.getElementById("iframe-vvv").contentDocument.dispatchEvent(iframeEvent);
}
*/
KeyManager.init();
var wkd = new openpgp.WKD();
var currentRecipients = [];
var source   = document.getElementById("iframe-key-table").innerHTML;
var template = Handlebars.compile(source);
var context = {sender: {pgp: true}, processedRecipients: []};
var html    = template(context);
var elem = document.getElementById("keybirdy-content").innerHTML = html;
//TODO: module for: renderSidebar, processedRecipients, processRecipients
//var processedRecipients = [];


/* KeyBirdy-Sidebar: Flow Overview
 * kbevent is received and passed to parentEventHandler
 * parentEventHandler starts processRecipients
 * processRecipients Flow for each key:
 * - Check if key lookup is already in progress, if true: skip key
 * - Save state in processedRecipients (state: wkd)
 * - Lookup WKD
 * - If key is found: update processedRecipients, return
 * - Check state, if state != wkd, return
 * - Save state in processedRecipients (state: keyserver)
 * - Lookup keys.openpgp.org
 * - If key is found: update processedRecipients, return
 * - Check state, if state != keyserver, return
 * - Save state in processedRecipients (state: local)
 * - Lookup Local GnuPG keyring
 * - Save state & key info in processedRecipients (state: done)
*/

var processedRecipients = {
	data: [],
	init: function () {
		this.data = [];
	},
	deleteElem: function(emailAddress) {
		for(var j=0; j < this.data.length; j++)
		{
			if(this.data[j].address === emailAddress)
			{
				this.data.splice(j, 1);
				j--;
			}
		}
	},
	push: function(inRecipient) {
		this.deleteElem(inRecipient.address);
		this.data.push(inRecipient);
		renderSidebar();
	},
	getStatus: function(address) {
		for(var j=0; j < this.data.length; j++)
		{
			if(this.data[j].address === address)
			{
				return this.data[j].status;
			}
		}
		return null;
	},
	setStatus: function(address, status) {
		/*
		for(var j=0; j < this.data.length; j++)
		{
			if(this.data[j].address === address)
			{
				this.data[j].status = status;
				return true;
			}
		}
		let recipientStatus = {};
		recipientStatus.status = status;
		recipientStatus.address = address;
		this.data.push(recipientStatus);
		return false;
		*/
	},
	isInProgress: function(address) {
		for(var j=0; j < this.data.length; j++)
		{
			if(this.data[j].address === address)
			{
				return true;
			}
		}
		return false;
	}
}

//console.log("Test: " + window.parent.document.getElementById("msgIdentity").description);

/**
 * Expects an object passed by the compose window, which contains a list of recipients and sender information. It then handles the lookup of keys.
 * @module keybirdy-sidebar
 * @param {String} e
 */
function parentEventHandler(e) {
	//TODO: delete log
	console.log("GOT DATA: " + JSON.stringify(e.detail));
	/*processedRecipients = */processRecipients(e.detail.recipients);
	currentRecipients = e.detail.recipients;
	hasPrivateKey = KeyManager.isPubKeyAvailable(e.detail.sender);
	renderSidebar();
}

/**
 * Renders the sidebar
 * @module keybirdy-sidebar
 */
function renderSidebar() {
	html = template({sender: {pgp: hasPrivateKey}, processedRecipients: filterRecipients(currentRecipients/*processedRecipients.data*/)});
	document.getElementById("keybirdy-content").innerHTML = html;
}

function filterRecipients(currentRecipients) {
	var filteredRecipients = [];
	console.log("currentRecipients: " + JSON.stringify(currentRecipients));
	console.log("processedRecipients: " + JSON.stringify(processedRecipients.data));

	for (var i=0; i < currentRecipients.length; i++)
	{
		for (var j=0; j < processedRecipients.data.length; j++)
		{
			console.log(processedRecipients.data[j].address + " != " + currentRecipients[i].address);
			if(processedRecipients.data[j].address == currentRecipients[i].address)
			{
				filteredRecipients.push(processedRecipients.data[j]);
				break;
			}
			else {
				console.log(processedRecipients.data[j].address + " != " + currentRecipients[i].address);
			}
		}
	}
	console.log("Filtered Recs: " + JSON.stringify(filteredRecipients));
	return filteredRecipients;
}

function processRecipients(recipients) {
	for (var i=0; i<recipients.length; i++)
	{
		//Start new implementation
		var currentRec = {};
		currentRec.address = recipients[i].address;



		wkd.lookup({email: recipients[i].address})
		.then(function(data){
			if (data) {
				console.log("GOT WKD-KEY: " + currentRec.address + ":" + data.keys[0].getUserIds()[0]);
				var rec = {};
				rec.address = currentRec.address;
				rec.isInKeyRing = true;
				rec.isImportable = true;
				rec.source = "WKD";
				processedRecipients.push(rec);
				GPGIPC.importKey(data.keys[0].armor(), function(result){
					console.log("imported key.")
				});
			}
			else {
				// Check keys.openpgp.org
				console.log("No WKD-KEY in response: " + currentRec.address);
				hkpClient.search(currentRec.address)
				.done(function(records, data, textStatus, jqXHR) {

					 //console.log("Search::Yeah!", records);
					 var rec = {};
					 rec.address = currentRec.address;
					 rec.isInKeyRing = true;
					 rec.isImportable = true;
					 rec.source = "keyserver";
					 processedRecipients.push(rec);
					 GPGIPC.importKey(records, function(result){
						 console.log("imported key.")
					 });
					 //TODO: update view/keylist
					 //currentRec.isImportable = true;
			 		 //processedRecs.push(currentRec);
				 })
				 .fail(function(jqXHR, textStatus, errorThrown) {
					 console.log("Unable to import key from hkp")
					 //TODO: CHECK LOCAL KEYRING!!!!!!!
					 	if (KeyManager.isPubKeyAvailable(currentRec.address))
	 			 		{
	 						rec.address = currentRec.address;
	 			 			currentRec.isInKeyring = true;
	 			 			currentRec.isImportable = true;
	 			 			currentRec.source = "local";
	 			 			console.log("Processed Recipient: PubKey Available: " + currentRec.address);
	 			 			processedRecipients.push(currentRec);
	 			 		}
						else
						{
								var rec = {};
		 					 rec.address = currentRec.address;
		 					 rec.isInKeyRing = false;
		 					 rec.isImportable = false;
		 					 rec.source = "none";
		 					 processedRecipients.push(rec);
						}

					 //TODO: check local keyring

					 //TODO: check local keyring
				   //console.log("Search::Bummer!", textStatus, errorThrown);
					 //currentRec.isImportable = false;
			 		 //processedRecs.push(currentRec);

				 });
			}

		},//TODO: is the next part needed?
		function(data) {
			/*
			//check keys.openpgp.org
			console.log("NO WKD Key found: " + currentRec.address + ":"+ data.message);
			hkpClient.search(currentRec.address)
			.done(function(records, data, textStatus, jqXHR) {

				 //console.log("Search::Yeah!", records);
				 var rec = {};
				 rec.address = currentRec.address;
				 rec.isInKeyRing = true;
				 rec.isImportable = true;
				 rec.source = "keyserver";
				 processedRecipients.push(rec);
				 GPGIPC.importKey(records, function(result){
					 console.log("imported key.")
				 });
				 //TODO: update view/keylist
				 //currentRec.isImportable = true;
		 		 //processedRecs.push(currentRec);
			 })
			 .fail(function(jqXHR, textStatus, errorThrown) {
				 // check local
				 	console.log("Unable to import key from hkp")
					if (KeyManager.isPubKeyAvailable(recipients[i].address))
			 		{
						rec.address = currentRec.address;
			 			currentRec.isInKeyring = true;
			 			currentRec.isImportable = true;
			 			currentRec.source = "local";
			 			console.log("Processed Recipient: PubKey Available: " + recipients[i].address);
			 			processedRecipients.push(currentRec);
			 		}
			   //console.log("Search::Bummer!", textStatus, errorThrown);
				 //currentRec.isImportable = false;
		 		 //processedRecs.push(currentRec);
			 });
		*/})
	}

	return processedRecipients;
}
document.addEventListener("kbevent", parentEventHandler, false);

</script>
</body>
</html>
